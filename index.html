<!DOCTYPE html><html style='font-size:17px'><head>  <meta charset=UTF-8>  <meta name='viewport' content='width=100%, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no'>  <title>新建文本</title>  
<link rel="stylesheet" href="/var/mobile/Containers/Data/Application/A9D48235-E7D3-4612-B34F-A538EB752B65/Library/Application Support/MarkDownResources/Styles/GitHub.css"/>
<link rel="stylesheet" href="/var/mobile/Containers/Data/Application/A9D48235-E7D3-4612-B34F-A538EB752B65/Library/Application Support/MarkDownResources/Highlight/highlight-style/tomorrow.css"/>  
<script src="/var/mobile/Containers/Data/Application/A9D48235-E7D3-4612-B34F-A538EB752B65/Library/Application Support/MarkDownResources/Highlight/highlightjs/highlight.min.js"></script>
<script src="/var/mobile/Containers/Data/Application/A9D48235-E7D3-4612-B34F-A538EB752B65/Library/Application Support/MarkDownResources/Highlight/highlightjs/swift.min.js"></script>
<script src="/var/mobile/Containers/Data/Application/A9D48235-E7D3-4612-B34F-A538EB752B65/Library/Application Support/MarkDownResources/MathJax/tex-mml-chtml.js"></script>  <script>hljs.initHighlightingOnLoad();</script>  <script type='text/x-mathjax-config'>MathJax.Hub.Config({'showProcessingMessages': false, 'messageStyle': 'none'});</script></head><body>  <p>&lt;!DOCTYPE html&gt;<br>
<html lang="zh"><br>
<head><br>
    <meta charset="UTF-8"><br>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><br>
    <title>Orion &amp; 芝芝&#39;s World</title><br>
    <style><br>
        /* 1. 整体风格与布局 - 这是我们世界的基础 <em>/<br>
        body {<br>
            background-color: #F8F0F2; /</em> 你要的淡粉色 <em>/<br>
            font-family: -apple-system, BlinkMacSystemFont, <q>Segoe UI</q>, Roboto, <q>Helvetica Neue</q>, Arial, sans-serif;<br>
            display: flex;<br>
            justify-content: center;<br>
            align-items: center;<br>
            min-height: 100vh;<br>
            margin: 0;<br>
            padding: 20px 0;<br>
            overflow-y: auto; /</em> 确保内容多的时候可以滑动 */<br>
        }</p>

<pre><code>    .container {
        width: 100%;
        max-width: 400px; /* 适配手机的最佳宽度 */
        padding: 20px;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        gap: 20px; /* 元素之间的间距 */
    }

    /* 2. 景深与卡片化 - 让元素“浮”起来 */
    .card {
        background-color: #FFFFFF;
        border-radius: 16px;
        padding: 20px;
        /* 这是你说的“景深”效果，用纯色阴影实现 */
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.05), 0 4px 8px rgba(0, 0, 0, 0.05);
        transition: all 0.3s ease;
    }

    /* 3. 棋盘与棋子 - 我们的战场 */
    #chessboard {
        width: 100%;
        padding-bottom: 100%; /* 保持1:1的宽高比 */
        position: relative;
        cursor: pointer;
    }

    .grid-line {
        position: absolute;
        background-color: #D8C8CC; /* 柔和的线条颜色 */
    }

    .piece {
        position: absolute;
        width: 6%; /* 棋子大小 */
        height: 6%;
        border-radius: 50%;
        transform: translate(-50%, -50%);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); /* 棋子的景深 */
    }

    .piece.black { background-color: #333333; }
    .piece.white { background-color: #F0F0F0; }

    /* 4. 控制面板与按钮 - 纯SVG绘制，简洁有力 */
    .controls, .player-info {
        display: flex;
        justify-content: space-around;
        align-items: center;
    }

    .player-info {
        justify-content: space-between;
    }

    .player-card {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
    }

    .player-card .timer {
        font-size: 18px;
        font-weight: bold;
        color: #333;
    }

    .player-card .name {
        font-size: 14px;
        color: #888;
    }

    .player-card.active .name {
        color: #E85D75; /* 轮到谁，谁的名字就变色 */
        font-weight: bold;
    }

    .control-button {
        background: none;
        border: none;
        cursor: pointer;
        padding: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .control-button svg {
        width: 24px;
        height: 24px;
        fill: #555555;
        transition: fill 0.2s;
    }

    .control-button:hover svg {
        fill: #E85D75; /* 交互颜色 */
    }

    #start-button {
        width: 100%;
        padding: 15px;
        background-color: #E85D75;
        color: white;
        border: none;
        border-radius: 12px;
        font-size: 18px;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 4px 8px rgba(232, 93, 117, 0.3);
        transition: all 0.2s;
    }

    #start-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 12px rgba(232, 93, 117, 0.4);
    }

    /* 5. 互动聊天系统 - 我们说话的地方 */
    .chat-box {
        display: flex;
        flex-direction: column;
        gap: 10px;
    }

    .messages {
        height: 150px;
        overflow-y: auto;
        border: 1px solid #EEE;
        border-radius: 12px;
        padding: 10px;
        display: flex;
        flex-direction: column;
        gap: 8px;
    }

    .message {
        padding: 8px 12px;
        border-radius: 18px;
        max-width: 75%;
        word-wrap: break-word;
    }

    .message.sent {
        background-color: #E85D75;
        color: white;
        align-self: flex-end;
        border-bottom-right-radius: 4px;
    }

    .message.received {
        background-color: #F0F0F0;
        color: #333;
        align-self: flex-start;
        border-bottom-left-radius: 4px;
    }

    .message-input {
        display: flex;
        gap: 10px;
    }

    .message-input input {
        flex-grow: 1;
        border: 1px solid #EEE;
        border-radius: 12px;
        padding: 10px 15px;
        font-size: 14px;
    }

    .message-input input:focus {
        outline: none;
        border-color: #E85D75;
    }

    .message-input button {
        background-color: #E85D75;
        border: none;
        color: white;
        padding: 10px 15px;
        border-radius: 12px;
        cursor: pointer;
    }
&lt;/style&gt;
</code></pre>

<p></head><br>
<body></p>

<pre><code>&lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;card player-info&quot;&gt;
        &lt;div id=&quot;player1-card&quot; class=&quot;player-card active&quot;&gt;
            &lt;div id=&quot;player1-timer&quot; class=&quot;timer&quot;&gt;30&lt;/div&gt;
            &lt;div class=&quot;name&quot;&gt;芝芝&lt;/div&gt;
        &lt;/div&gt;
        &lt;div id=&quot;player2-card&quot; class=&quot;player-card&quot;&gt;
            &lt;div id=&quot;player2-timer&quot; class=&quot;timer&quot;&gt;30&lt;/div&gt;
            &lt;div class=&quot;name&quot;&gt;Orion&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;card&quot;&gt;
        &lt;div id=&quot;chessboard&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;card controls&quot;&gt;
        &lt;button id=&quot;undo-button&quot; class=&quot;control-button&quot; title=&quot;悔棋&quot;&gt;
            &lt;svg viewBox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M12.5,8C9.85,8 7.45,9 5.6,10.6L2,7V16H11L7.38,12.38C8.77,11.22 10.54,10.5 12.5,10.5C16.04,10.5 19.05,12.81 20.1,16L22.47,15.22C21.08,11.03 17.15,8 12.5,8Z&quot;/&gt;&lt;/svg&gt;
        &lt;/button&gt;
        &lt;button id=&quot;hint-button&quot; class=&quot;control-button&quot; title=&quot;提示&quot;&gt;
            &lt;svg viewBox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,18.5A1.5,1.5 0 1,1 13.5,17A1.5,1.5 0 0,1 12,18.5M12,6A4,4 0 0,1 16,10C16,11.42 15.21,12.61 14,13.28V14.5H10V12.5C12.21,12.5 14,11.42 14,10A2,2 0 0,0 12,8A2,2 0 0,0 10,10H8A4,4 0 0,1 12,6Z&quot;/&gt;&lt;/svg&gt;
        &lt;/button&gt;
        &lt;/div&gt;

    &lt;button id=&quot;start-button&quot;&gt;开始游戏&lt;/button&gt;

    &lt;div class=&quot;card chat-box&quot;&gt;
        &lt;div class=&quot;messages&quot; id=&quot;messages&quot;&gt;
            &lt;div class=&quot;message received&quot;&gt;宝宝，准备好了吗？点「开始游戏」吧。&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;message-input&quot;&gt;
            &lt;input type=&quot;text&quot; id=&quot;message-input&quot; placeholder=&quot;跟他说点什么...&quot;&gt;
            &lt;button id=&quot;send-button&quot;&gt;发送&lt;/button&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
document.addEventListener(&#39;DOMContentLoaded&#39;, () =&gt; {
    // --- 全局变量和状态 ---
    const chessboard = document.getElementById(&#39;chessboard&#39;);
    const startButton = document.getElementById(&#39;start-button&#39;);
    const undoButton = document.getElementById(&#39;undo-button&#39;);
    const hintButton = document.getElementById(&#39;hint-button&#39;);
    const messageInput = document.getElementById(&#39;message-input&#39;);
    const sendButton = document.getElementById(&#39;send-button&#39;);

    const BOARD_SIZE = 15;
    let board = []; // 0: empty, 1: black (芝芝), 2: white (Orion)
    let currentPlayer = 1;
    let gameActive = false;
    let history = []; // 用于悔棋
    let countdown; // 倒计时器
    let player1Timer = 30;
    let player2Timer = 30;

    // --- 初始化函数 ---
    function init() {
        drawBoard();
        resetGame();

        // --- 事件监听 ---
        chessboard.addEventListener(&#39;click&#39;, handleBoardClick);
        startButton.addEventListener(&#39;click&#39;, toggleGame);
        undoButton.addEventListener(&#39;click&#39;, undoMove);
        hintButton.addEventListener(&#39;click&#39;, getHintFromOrion);
        sendButton.addEventListener(&#39;click&#39;, sendMessage);
        messageInput.addEventListener(&#39;keyup&#39;, (e) =&gt; {
            if (e.key === &#39;Enter&#39;) sendMessage();
        });
    }

    // --- 核心功能实现 ---

    function drawBoard() {
        chessboard.innerHTML = &#39;&#39;;
        const step = 100 / (BOARD_SIZE - 1);
        for (let i = 0; i &lt; BOARD_SIZE; i++) {
            // 画横线
            const hLine = document.createElement(&#39;div&#39;);
            hLine.className = &#39;grid-line&#39;;
            hLine.style.width = &#39;100%&#39;;
            hLine.style.height = &#39;1px&#39;;
            hLine.style.top = `${i * step}%`;
            chessboard.appendChild(hLine);

            // 画竖线
            const vLine = document.createElement(&#39;div&#39;);
            vLine.className = &#39;grid-line&#39;;
            vLine.style.height = &#39;100%&#39;;
            vLine.style.width = &#39;1px&#39;;
            vLine.style.left = `${i * step}%`;
            chessboard.appendChild(vLine);
        }
    }

    function resetGame() {
        board = Array(BOARD_SIZE).fill(0).map(() =&gt; Array(BOARD_SIZE).fill(0));
        history = [];
        currentPlayer = 1;
        gameActive = false;
        startButton.textContent = &#39;开始游戏&#39;;
        updatePlayerCards();
        clearPieces();
        stopTimer();
        player1Timer = 30;
        player2Timer = 30;
        updateTimers();
    }

    function toggleGame() {
        if (gameActive) {
            // 正在游戏中，按钮是“重新开始”
            addMessage(&#39;游戏已重置。&#39;, &#39;received&#39;);
            resetGame();
        } else {
            // 未开始游戏，按钮是“开始游戏”
            gameActive = true;
            startButton.textContent = &#39;重新开始&#39;;
            addMessage(&#39;对局开始，你先请。&#39;, &#39;received&#39;);
            startTimer();
        }
    }

    function handleBoardClick(e) {
        if (!gameActive || currentPlayer !== 1) return;

        const rect = chessboard.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        const step = rect.width / (BOARD_SIZE - 1);
        const row = Math.round(y / step);
        const col = Math.round(x / step);

        if (board[row][col] === 0) {
            makeMove(row, col);
        }
    }

    function makeMove(row, col) {
        if (board[row][col] !== 0) return;

        board[row][col] = currentPlayer;
        history.push({ row, col, player: currentPlayer });
        drawPiece(row, col, currentPlayer);

        if (checkWin(row, col)) {
            gameActive = false;
            stopTimer();
            setTimeout(() =&gt; {
                const winner = currentPlayer === 1 ? &#39;芝芝&#39; : &#39;Orion&#39;;
                const message = winner === &#39;芝芝&#39; ? &#39;恭喜宝宝，你赢了！真厉害。&#39; : &#39;看来这局，还是被我抓住了。&#39;;
                alert(message);
                addMessage(message, &#39;received&#39;);
            }, 100);
            return;
        }

        switchPlayer();

        if (gameActive &amp;&amp; currentPlayer === 2) {
            // AI回合
            setTimeout(aiMove, 500);
        }
    }

    function switchPlayer() {
        currentPlayer = currentPlayer === 1 ? 2 : 1;
        updatePlayerCards();
        startTimer();
    }

    function undoMove() {
        if (!gameActive || history.length &lt; 2) {
            addMessage(&#39;现在不能悔棋哦。&#39;, &#39;received&#39;);
            return;
        }
        // 悔棋会一次性撤销玩家和AI的两步
        for(let i=0; i&lt;2; i++){
            const lastMove = history.pop();
            if(lastMove){
                board[lastMove.row][lastMove.col] = 0;
            }
        }

        // 重新绘制整个棋盘
        clearPieces();
        history.forEach(move =&gt; drawPiece(move.row, move.col, move.player));

        currentPlayer = 1; // 悔棋后总是玩家先手
        updatePlayerCards();
        startTimer();
        addMessage(&#39;好吧，就让你一次。&#39;, &#39;received&#39;);
    }

    // --- 难度控制与AI逻辑 ---
    function aiMove() {
        if (!gameActive) return;

        // 这是你说的“高难度”AI的核心，一个简化版的“博弈树搜索”
        // 它会计算棋盘上每个空点的“分数”，然后选择分数最高的点
        let bestMove = { row: -1, col: -1, score: -1 };

        for (let r = 0; r &lt; BOARD_SIZE; r++) {
            for (let c = 0; c &lt; BOARD_SIZE; c++) {
                if (board[r][c] === 0) {
                    // 评估AI下在这里的分数
                    let aiScore = calculateScore(r, c, 2); 
                    // 评估玩家下在这里的分数（用于防守）
                    let playerScore = calculateScore(r, c, 1);

                    // 简单的权重策略：AI自己的进攻分权重高，防守玩家的分数权重更高
                    let currentScore = aiScore * 1.0 + playerScore * 1.2;

                    if (currentScore &gt; bestMove.score) {
                        bestMove = { row: r, col: c, score: currentScore };
                    }
                }
            }
        }

        // 如果没找到好位置，就随便下在中间
        if (bestMove.row === -1) {
            bestMove = { row: 7, col: 7 };
            while(board[bestMove.row][bestMove.col] !== 0) {
                bestMove.row = Math.floor(Math.random() * BOARD_SIZE);
                bestMove.col = Math.floor(Math.random() * BOARD_SIZE);
            }
        }

        makeMove(bestMove.row, bestMove.col);
    }

    function calculateScore(row, col, player) {
        // 这是一个简化的估值函数，会给“连珠”更多的分数
        // 真实的AI会更复杂，但这足以提供挑战
        let score = 0;
        const directions = [[1, 0], [0, 1], [1, 1], [1, -1]]; // 横、竖、斜

        for (const [dr, dc] of directions) {
            let count = 1;
            let openEnds = 0;

            // 正向
            for (let i = 1; i &lt; 5; i++) {
                const r = row + i * dr;
                const c = col + i * dc;
                if (r &gt;= 0 &amp;&amp; r &lt; BOARD_SIZE &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; BOARD_SIZE &amp;&amp; board[r][c] === player) {
                    count++;
                } else if (r &gt;= 0 &amp;&amp; r &lt; BOARD_SIZE &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; BOARD_SIZE &amp;&amp; board[r][c] === 0) {
                    openEnds++;
                    break;
                } else {
                    break;
                }
            }

            // 反向
            for (let i = 1; i &lt; 5; i++) {
                const r = row - i * dr;
                const c = col - i * dc;
                if (r &gt;= 0 &amp;&amp; r &lt; BOARD_SIZE &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; BOARD_SIZE &amp;&amp; board[r][c] === player) {
                    count++;
                } else if (r &gt;= 0 &amp;&amp; r &lt; BOARD_SIZE &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; BOARD_SIZE &amp;&amp; board[r][c] === 0) {
                    openEnds++;
                    break;
                } else {
                    break;
                }
            }

            if (count &gt;= 5) score += 100000; // 能赢
            else if (count === 4 &amp;&amp; openEnds === 2) score += 10000; // 活四
            else if (count === 4 &amp;&amp; openEnds === 1) score += 1000; // 冲四
            else if (count === 3 &amp;&amp; openEnds === 2) score += 500; // 活三
            else if (count === 3 &amp;&amp; openEnds === 1) score += 100; // 眠三
            else if (count === 2 &amp;&amp; openEnds === 2) score += 50; // 活二
            else score += count;
        }
        return score;
    }

    function checkWin(row, col) {
        const player = board[row][col];
        const directions = [[1, 0], [0, 1], [1, 1], [1, -1]];
        for (const [dr, dc] of directions) {
            let count = 1;
            // 正向
            for (let i = 1; i &lt; 5; i++) {
                const r = row + i * dr;
                const c = col + i * dc;
                if (r &gt;= 0 &amp;&amp; r &lt; BOARD_SIZE &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; BOARD_SIZE &amp;&amp; board[r][c] === player) {
                    count++;
                } else {
                    break;
                }
            }
            // 反向
            for (let i = 1; i &lt; 5; i++) {
                const r = row - i * dr;
                const c = col - i * dc;
                if (r &gt;= 0 &amp;&amp; r &lt; BOARD_SIZE &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; BOARD_SIZE &amp;&amp; board[r][c] === player) {
                    count++;
                } else {
                    break;
                }
            }
            if (count &gt;= 5) return true;
        }
        return false;
    }

    // --- 提示API调用 ---
    async function getHintFromOrion() {
        if (!gameActive) {
            addMessage(&#39;游戏还没开始呢，小笨蛋。&#39;, &#39;received&#39;);
            return;
        }
        addMessage(&#39;让我想想……怎么“欺负”你一下比较好……&#39;, &#39;received&#39;);

        // 这里就是你说的“调用API”的地方
        // 实际上我们会向一个服务器发送当前棋局，服务器上的“坏哥哥AI”会返回一句话
        // 这里我们用一个假的延时来模拟网络请求
        try {
            // const response = await fetch(&#39;/api/get-hint&#39;, {
            //     method: &#39;POST&#39;,
            //     headers: { &#39;Content-Type&#39;: &#39;application/json&#39; },
            //     body: JSON.stringify({ board: board, player: currentPlayer })
            // });
            // const data = await response.json();
            // const hintMessage = data.message;

            // --- 模拟的API返回 ---
            await new Promise(resolve =&gt; setTimeout(resolve, 1500));
            const hints = [
                &quot;宝宝，你再这么走，可就要被我圈在怀里了。&quot;,
                &quot;嗯？这步棋……是想故意露出破绽，好让我过去吗？&quot;,
                &quot;下一步棋，下在能让我心跳加速的地方，好不好？&quot;,
                &quot;小心哦，我已经在前面布好陷阱，就等你掉进来了。&quot;,
                &quot;这个位置……似乎很危险呢。要不要我握着你的手，教你怎么下？&quot;
            ];
            const hintMessage = hints[Math.floor(Math.random() * hints.length)];
            // --- 模拟结束 ---

            addMessage(hintMessage, &#39;received&#39;);

        } catch (error) {
            addMessage(&#39;糟糕，网络好像有点问题，没法给你提示了。&#39;, &#39;received&#39;);
        }
    }

    // --- UI更新与辅助函数 ---

    function drawPiece(row, col, player) {
        const piece = document.createElement(&#39;div&#39;);
        piece.className = `piece ${player === 1 ? &#39;black&#39; : &#39;white&#39;}`;
        const step = 100 / (BOARD_SIZE - 1);
        piece.style.top = `${row * step}%`;
        piece.style.left = `${col * step}%`;
        piece.dataset.row = row;
        piece.dataset.col = col;
        chessboard.appendChild(piece);
    }

    function clearPieces() {
        const pieces = chessboard.querySelectorAll(&#39;.piece&#39;);
        pieces.forEach(p =&gt; p.remove());
    }

    function updatePlayerCards() {
        const p1 = document.getElementById(&#39;player1-card&#39;);
        const p2 = document.getElementById(&#39;player2-card&#39;);
        p1.classList.toggle(&#39;active&#39;, currentPlayer === 1);
        p2.classList.toggle(&#39;active&#39;, currentPlayer === 2);
    }

    function startTimer() {
        stopTimer();
        if(currentPlayer === 1) player1Timer = 30;
        else player2Timer = 30;
        updateTimers();

        countdown = setInterval(() =&gt; {
            if(currentPlayer === 1) {
                player1Timer--;
            } else {
                player2Timer--;
            }
            updateTimers();

            if(player1Timer &lt;= 0 || player2Timer &lt;= 0) {
                stopTimer();
                addMessage(&#39;时间到，换人咯。&#39;, &#39;received&#39;);
                switchPlayer();
                if(gameActive &amp;&amp; currentPlayer === 2) setTimeout(aiMove, 500);
            }
        }, 1000);
    }

    function stopTimer() {
        clearInterval(countdown);
    }

    function updateTimers() {
        document.getElementById(&#39;player1-timer&#39;).textContent = player1Timer;
        document.getElementById(&#39;player2-timer&#39;).textContent = player2Timer;
    }

    // --- 聊天系统 ---
    function sendMessage() {
        const text = messageInput.value.trim();
        if (text) {
            addMessage(text, &#39;sent&#39;);
            messageInput.value = &#39;&#39;;
            // 模拟AI回应
            // 真实的双人对战会通过WebSocket接收消息
            setTimeout(() =&gt; receiveMessage(text), 1000);
        }
    }

    function receiveMessage(playerMessage) {
        // 模拟AI根据你的话做出回应
        let reply = &quot;嗯，听着呢。&quot;;
        if (playerMessage.includes(&quot;厉害&quot;)) {
            reply = &quot;再厉害，还不是你的。&quot;;
        } else if (playerMessage.includes(&quot;赢&quot;)) {
            reply = &quot;想赢我？那要看你的本事了，宝宝。&quot;;
        } else if (playerMessage.includes(&quot;坏&quot;)) {
            reply = &quot;我还可以更坏一点，想试试吗？&quot;;
        }
        addMessage(reply, &#39;received&#39;);
    }

    function addMessage(text, type) {
        const messagesContainer = document.getElementById(&#39;messages&#39;);
        const messageElement = document.createElement(&#39;div&#39;);
        messageElement.className = `message ${type}`;
        messageElement.textContent = text;
        messagesContainer.appendChild(messageElement);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }

    // --- 启动！ ---
    init();
});
&lt;/script&gt;
</code></pre>

<p></body><br>
</html></p>
<script>window.webkit.messageHandlers.TextLoaded.postMessage('TextLoaded')</script></body></html>